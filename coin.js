var coinSource = 'contract owned { address public owner; function owned() { owner = msg.sender; } modifier onlyOwner { if (msg.sender != owner) throw; _ } function transferOwnership(address newOwner) onlyOwner { owner = newOwner; } } contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); } contract token { /* Public variables of the token */ string public standard = "Scamion"; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; /* This creates an array with all balances */ mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; /* This generates a public event on the blockchain that will notify clients */ event Transfer(address indexed from, address indexed to, uint256 value); /* Initializes contract with initial supply tokens to the creator of the contract */ function token( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply; /* Give the creator all initial tokens */ totalSupply = initialSupply; /* Update total supply */ name = tokenName; /* Set the name for display purposes */ symbol = tokenSymbol; /* Set the symbol for display purposes */ decimals = decimalUnits; /* Amount of decimals for display purposes */ } /* Send coins */ function transfer(address _to, uint256 _value) { if (balanceOf[msg.sender] < _value) throw; /* Check if the sender has enough */ if (balanceOf[_to] + _value < balanceOf[_to]) throw; /* Check for overflows */ balanceOf[msg.sender] -= _value; /* Subtract from the sender */ balanceOf[_to] += _value; /* Add the same to the recipient */ Transfer(msg.sender, _to, _value); /* Notify anyone listening that this transfer took place */ } /* Allow another contract to spend some tokens in your behalf */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowance[msg.sender][_spender] = _value; tokenRecipient spender = tokenRecipient(_spender); spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } /* A contract attempts to get the coins */ function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balanceOf[_from] < _value) throw; /* Check if the sender has enough */ if (balanceOf[_to] + _value < balanceOf[_to]) throw; /* Check for overflows */ if (_value > allowance[_from][msg.sender]) throw; /* Check allowance */ balanceOf[_from] -= _value; /* Subtract from the sender */ balanceOf[_to] += _value; /* Add the same to the recipient */ allowance[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } /* This unnamed function is called whenever someone tries to send ether to it */ function () { throw; /* Prevents accidental sending of ether */ } } contract Scamions is owned, token { uint256 public sellPrice; uint256 public buyPrice; uint256 public totalSupply; mapping (address => bool) public frozenAccount; /* This generates a public event on the blockchain that will notify clients */ event FrozenFunds(address target, bool frozen); /* Initializes contract with initial supply tokens to the creator of the contract */ function Scamions( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol, address centralMinter ) { if(centralMinter != 0 ) owner = msg.sender; /* Sets the minter */ balanceOf[msg.sender] = initialSupply; /* Give the creator all initial tokens */ name = tokenName; /* Set the name for display purposes */ symbol = tokenSymbol; /* Set the symbol for display purposes */ decimals = decimalUnits; /* Amount of decimals for display purposes */ totalSupply = initialSupply; } /* Send coins */ function transfer(address _to, uint256 _value) { if (balanceOf[msg.sender] < _value) throw; /* Check if the sender has enough */ if (balanceOf[_to] + _value < balanceOf[_to]) throw; /* Check for overflows */ if (frozenAccount[msg.sender]) throw; /* Check if frozen */ balanceOf[msg.sender] -= _value; /* Subtract from the sender */ balanceOf[_to] += _value; /* Add the same to the recipient */ Transfer(msg.sender, _to, _value); /* Notify anyone listening that this transfer took place */ } /* A contract attempts to get the coins */ function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (frozenAccount[_from]) throw; /* Check if frozen */ if (balanceOf[_from] < _value) throw; /* Check if the sender has enough */ if (balanceOf[_to] + _value < balanceOf[_to]) throw; /* Check for overflows */ if (_value > allowance[_from][msg.sender]) throw; /* Check allowance */ balanceOf[_from] -= _value; /* Subtract from the sender */ balanceOf[_to] += _value; /* Add the same to the recipient */ allowance[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } function mintToken(address target, uint256 mintedAmount) onlyOwner { balanceOf[target] += mintedAmount; totalSupply += mintedAmount; Transfer(0, owner, mintedAmount); Transfer(owner, target, mintedAmount); } function freezeAccount(address target, bool freeze) onlyOwner { frozenAccount[target] = freeze; FrozenFunds(target, freeze); } function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner { sellPrice = newSellPrice; buyPrice = newBuyPrice; } function buy() { uint amount = msg.value / buyPrice; /* calculates the amount */ if (balanceOf[this] < amount) throw; /* checks if it has enough to sell */ balanceOf[msg.sender] += amount; /* adds the amount to buyers balance */ balanceOf[this] -= amount; /* subtracts amount from sellers balance */ Transfer(this, msg.sender, amount); /* execute an event reflecting the change */ } function sell(uint256 amount) { if (balanceOf[msg.sender] < amount ) throw; /* checks if the sender has enough to sell */ balanceOf[this] += amount; /* adds the amount to owners balance */ balanceOf[msg.sender] -= amount; /* subtracts the amount from sellers balance */ msg.sender.send(amount * sellPrice); /* sends ether to the seller */ Transfer(msg.sender, this, amount); /* executes an event reflecting on the change */ } }';

var coinCompiled = web3.eth.compile.solidity(coinSource);

var _initialSupply = 10000;
var _tokenName = "Scamion";
var _decimalUnits = 0;
var _tokenSymbol = "$";
var _centralMinter = 0xa47ab0de78a67c28cc167c1e3068c456aca29915;

var coinContract = web3.eth.contract(coinCompiled.Scamions.info.abiDefinition);

var coins = coinContract.new(_initialSupply, _tokenName, _decimalUnits, _tokenSymbol, _centralMinter, {from: web3.eth.accounts[0], data: coinCompiled.Scamions.code, gas: 300000}, function(e, contract){
	if(!e) {
		if(!contract.address){
			console.log("Contract transaction send: TransactionHash: " + contract.transactionHash + " waiting to be mined...");
	} else {
		console.log("Contract mined! Address: " + contract.address);
		console.log(contract);
	}
}
});


